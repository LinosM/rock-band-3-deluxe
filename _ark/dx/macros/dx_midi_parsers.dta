{new
   MidiParser
   guitar_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type midi_parser)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_guitar_gem_tracked
         {set $first_guitar_gem_tracked TRUE}
         {set $first_guitar_gem_beat $mp.start}
         {push_back $guitar_note_tracker ({sprint $current_beat} $first_guitar_gem_beat)}
      }
      {if {&& {> $mp.prev_start 4} {< $mp.prev_start 10000}}
         {set $guitar_tracked_start $mp.start}
         {set $guitar_tracked_prev_end {- $guitar_tracked_start $mp.prev_start}}
         {foreach $entry $guitar_note_tracker
            {if {== {elem $entry 0} {sprint $guitar_tracked_prev_end}}
               {remove_elem {find $guitar_note_tracker {sprint $guitar_tracked_prev_end}} {elem {find $guitar_note_tracker {sprint $guitar_tracked_prev_end}} 1}}
               {push_back $guitar_note_tracker ({sprint $guitar_tracked_prev_end} $guitar_tracked_start)}
            }
         }
         {foreach $entry $guitar_note_tracker
            {if {!= {elem $entry 0} {sprint $guitar_tracked_prev_end}}
               {set $pushtime_guitar TRUE} ;get ready to push it
            }
         }
         {foreach $entry $guitar_note_tracker
            {if {== {elem $entry 0} {sprint $guitar_tracked_prev_end}}
               {set $pushtime_guitar FALSE} ;dont push it
            }
         }
         {if $pushtime_guitar ;if we need to push
            {push_back $guitar_note_tracker ({sprint $guitar_tracked_prev_end} $guitar_tracked_start)}
         }
         {set $guitar_note_tracker {array $guitar_note_tracker}}
         ;{dx_log_writer TRUE $guitar_note_tracker}
      }
   )
}
{new
   MidiParser
   drum_timer
   (track_name 'PART DRUMS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type midi_parser)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_drum_gem_tracked
         {set $first_drum_gem_tracked TRUE}
         {set $first_drum_gem_beat $mp.start}
         {push_back $drum_note_tracker ({sprint $current_beat} $first_drum_gem_beat)}
      }
      {if {&& {> $mp.prev_start 4} {< $mp.prev_start 10000}}
         {set $drum_tracked_start $mp.start}
         {set $drum_tracked_prev_end {- $drum_tracked_start $mp.prev_start}}
         {foreach $entry $drum_note_tracker
            {if {== {elem $entry 0} {sprint $drum_tracked_prev_end}}
               {remove_elem {find $drum_note_tracker {sprint $drum_tracked_prev_end}} {elem {find $drum_note_tracker {sprint $drum_tracked_prev_end}} 1}}
               {push_back $drum_note_tracker ({sprint $drum_tracked_prev_end} $drum_tracked_start)}
            }
         }
         {foreach $entry $drum_note_tracker
            {if {!= {elem $entry 0} {sprint $drum_tracked_prev_end}}
               {set $pushtime_drum TRUE} ;get ready to push it
            }
         }
         {foreach $entry $drum_note_tracker
            {if {== {elem $entry 0} {sprint $drum_tracked_prev_end}}
               {set $pushtime_drum FALSE} ;dont push it
            }
         }
         {if $pushtime_drum ;if we need to push
            {push_back $drum_note_tracker ({sprint $drum_tracked_prev_end} $drum_tracked_start)}
         }
         {set $drum_note_tracker {array $drum_note_tracker}}
         ;{dx_log_writer TRUE $drum_note_tracker}
      }
   )
}
{new
   MidiParser
   bass_timer
   (track_name 'PART BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type midi_parser)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_bass_gem_tracked
         {set $first_bass_gem_tracked TRUE}
         {set $first_bass_gem_beat $mp.start}
         {push_back $bass_note_tracker ({sprint $current_beat} $first_bass_gem_beat)}
      }
      {if {&& {> $mp.prev_start 4} {< $mp.prev_start 10000}}
         {set $bass_tracked_start $mp.start}
         {set $bass_tracked_prev_end {- $bass_tracked_start $mp.prev_start}}
         {foreach $entry $bass_note_tracker
            {if {== {elem $entry 0} {sprint $bass_tracked_prev_end}}
               {remove_elem {find $bass_note_tracker {sprint $bass_tracked_prev_end}} {elem {find $bass_note_tracker {sprint $bass_tracked_prev_end}} 1}}
               {push_back $bass_note_tracker ({sprint $bass_tracked_prev_end} $bass_tracked_start)}
            }
         }
         {foreach $entry $bass_note_tracker
            {if {!= {elem $entry 0} {sprint $bass_tracked_prev_end}}
               {set $pushtime_bass TRUE} ;get ready to push it
            }
         }
         {foreach $entry $bass_note_tracker
            {if {== {elem $entry 0} {sprint $bass_tracked_prev_end}}
               {set $pushtime_bass FALSE} ;dont push it
            }
         }
         {if $pushtime_bass ;if we need to push
            {push_back $bass_note_tracker ({sprint $bass_tracked_prev_end} $bass_tracked_start)}
         }
         {set $bass_note_tracker {array $bass_note_tracker}}
         ;{dx_log_writer TRUE $bass_note_tracker}
      }
   )
}
{new
   MidiParser
   keys_timer
   (track_name 'PART KEYS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress FALSE)
   (message_type midi_parser)
   (init
      {set
         [min_gap]
         4}
      {set
         [max_gap]
         10000}
   )
   (mp.up FALSE)
   (idle)
   (gem
      {unless $first_keys_gem_tracked
         {set $first_keys_gem_tracked TRUE}
         {set $first_keys_gem_beat $mp.start}
         {push_back $keys_note_tracker ({sprint $current_beat} $first_keys_gem_beat)}
      }
      {if {&& {> $mp.prev_start 4} {< $mp.prev_start 10000}}
         {set $keys_tracked_start $mp.start}
         {set $keys_tracked_prev_end {- $keys_tracked_start $mp.prev_start}}
         {foreach $entry $keys_note_tracker
            {if {== {elem $entry 0} {sprint $keys_tracked_prev_end}}
               {remove_elem {find $keys_note_tracker {sprint $keys_tracked_prev_end}} {elem {find $keys_note_tracker {sprint $keys_tracked_prev_end}} 1}}
               {push_back $keys_note_tracker ({sprint $keys_tracked_prev_end} $keys_tracked_start)}
            }
         }
         {foreach $entry $keys_note_tracker
            {if {!= {elem $entry 0} {sprint $keys_tracked_prev_end}}
               {set $pushtime_keys TRUE} ;get ready to push it
            }
         }
         {foreach $entry $keys_note_tracker
            {if {== {elem $entry 0} {sprint $keys_tracked_prev_end}}
               {set $pushtime_keys FALSE} ;dont push it
            }
         }
         {if $pushtime_keys ;if we need to push
            {push_back $keys_note_tracker ({sprint $keys_tracked_prev_end} $keys_tracked_start)}
         }
         {set $keys_note_tracker {array $keys_note_tracker}}
         {dx_log_writer TRUE $keys_note_tracker}
      }
   )
}
{new
   MidiParser
   guitar_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   (message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
         (96 97 98 99 100))
   (gem
      {unless $first_guitar_gem_tracked
         {set $first_guitar_gem_tracked TRUE}
         {set $first_guitar_gem_beat {int $mp.start}}
         {push_back $guitar_note_tracker ("delay_0" 0 $first_guitar_gem_beat)}
         {set $guitar_note_tracker {array $guitar_note_tracker}}
         {set $tracked_break_num_guitar 1}
      }
      {if {&& {>= $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $guitar_tracked_start {int $mp.start}}
         {set $guitar_tracked_prev_end {int {- $guitar_tracked_start $mp.prev_start}}}
         {push_back $guitar_note_tracker ({sprint "delay_" $tracked_break_num_guitar} $guitar_tracked_prev_end $guitar_tracked_start)}
         {set $guitar_note_tracker {array $guitar_note_tracker}}
         {set $tracked_break_num_guitar {+ $tracked_break_num_guitar 1}}
         ;{dx_log_writer TRUE $guitar_note_tracker}
      }
   )
}
{new
   MidiParser
   drum_timer
   (track_name 'PART DRUMS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   (message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
         (96 97 98 99 100))
   (gem
      {unless $first_drum_gem_tracked
         {set $first_drum_gem_tracked TRUE}
         {set $first_drum_gem_beat {int $mp.start}}
         {push_back $drum_note_tracker ("delay_0" 0 $first_drum_gem_beat)}
         {set $drum_note_tracker {array $drum_note_tracker}}
         {set $tracked_break_num_drum 1}
      }
      {if {&& {>= $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $drum_tracked_start {int $mp.start}}
         {set $drum_tracked_prev_end {int {- $drum_tracked_start $mp.prev_start}}}
         {push_back $drum_note_tracker ({sprint "delay_" $tracked_break_num_drum} $drum_tracked_prev_end $drum_tracked_start)}
         {set $drum_note_tracker {array $drum_note_tracker}}
         {set $tracked_break_num_drum {+ $tracked_break_num_drum 1}}
         ;{dx_log_writer TRUE $drum_note_tracker}
      }
   )
}
{new
   MidiParser
   bass_timer
   (track_name 'PART BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   (message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
         (96 97 98 99 100))
   (gem
      {unless $first_bass_gem_tracked
         {set $first_bass_gem_tracked TRUE}
         {set $first_bass_gem_beat {int $mp.start}}
         {push_back $bass_note_tracker ("delay_0" 0 $first_bass_gem_beat)}
         {set $bass_note_tracker {array $bass_note_tracker}}
         {set $tracked_break_num_bass 1}
      }
      {if {&& {>= $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $bass_tracked_start {int $mp.start}}
         {set $bass_tracked_prev_end {int {- $bass_tracked_start $mp.prev_start}}}
         {push_back $bass_note_tracker ({sprint "delay_" $tracked_break_num_bass} $bass_tracked_prev_end $bass_tracked_start)}
         {set $bass_note_tracker {array $bass_note_tracker}}
         {set $tracked_break_num_bass {+ $tracked_break_num_bass 1}}
         ;{dx_log_writer TRUE $bass_note_tracker}
      }
   )
}
{new
   MidiParser
   keys_timer
   (track_name 'PART KEYS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   (message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
         (96 97 98 99 100))
   (gem
      {$this rt_compute_space}
      {unless $first_keys_gem_tracked
         {set $first_keys_gem_tracked TRUE}
         {set $first_keys_gem_beat {int $mp.start}}
         {push_back $keys_note_tracker ("delay_0" 0 $first_keys_gem_beat)}
         {set $keys_note_tracker {array $keys_note_tracker}}
         {set $tracked_break_num_keys 1}
      }
      {if {&& {>= $mp.prev_start 8} {< $mp.prev_start 10000}}
         {set $keys_tracked_start {int $mp.start}}
         {set $keys_tracked_prev_end {int {- $keys_tracked_start $mp.prev_start}}}
         {push_back $keys_note_tracker ({sprint "delay_" $tracked_break_num_keys} $keys_tracked_prev_end $keys_tracked_start)}
         {set $keys_note_tracker {array $keys_note_tracker}}
         {set $tracked_break_num_keys {+ $tracked_break_num_keys 1}}
         ;{dx_log_writer TRUE $keys_note_tracker}
      }
   )
}